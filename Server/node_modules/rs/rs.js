/*
 * node-rs: Rapidshare API Implementation
 * Copyright (C) 2012 dxld <dxld Ã„T darkboxed DOT org>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var fs = require('fs');
var URL = require('url');
var util = require('util');
var http = require('http');
var https = require('https');
var path = require('path');
var async = require('async');
var query = require('querystring')
var Stream = require('stream');
var request = require('request');

var ClampedStream = require('./clamped-stream');
var utils = require('./utils');

module.exports = {
    createSession: createSession,

    url: rsurl,
    kvresp: rskvresp,
    aresp: rsaresp,
    call: rscall
};

var API = '/cgi-bin/rsapi.cgi';
var BASE_SECURE = 'https://api.rapidshare.com' + API;
var BASE = 'http://api.rapidshare.com' + API;

/******************************************************************************
 * RapidShare API functions
 */

function rsurl(base, params) {
    return base + '?' + query.stringify(params);
}

function rskvresp(body) {
    if(body.match(/ERROR:/))
        throw body;

    var kvs = body.split('\n')
        .map(function(line){
            return line.split('=');
        });

    var obj = {};
    kvs.forEach(function(kv){
        if(kv[0]) obj[kv[0]] = kv[1];
    });

    return obj;
}

function rslmap(line, keys) {
    if(!line) return;

    var fields = line.split(',');

    var obj = {};
    keys.forEach(function(key, i){
        obj[key] = fields[i];
    });

    return obj;

}

function rsaresp(body, keys) {
    var lines = body
        .split('\n')
        .filter(function(e){ return e.length > 0 });

    var ret = lines.map(function(line){
        return rslmap(line, keys);
    });

    return ret;
}

function rscall(sub, opts, callback) {
    if(typeof opts == 'function') {
        callback = opts;
        opts = {};
    } else if(typeof opts == 'string') {
        opts = { cookie: opts }
    }

    opts.sub = sub;
    var url = rsurl(BASE_SECURE, opts);

    request(url, function(err, res, body) {
        if(err) { callback(err); return; }

        callback(null, body);
    });
}

/* Session class
 */
function RSSession(cookie) {
    this.cookie = cookie || '';
}

function createSession() {
    return new RSSession();
}

RSSession.prototype.login = function(user, password, callback) {
    var self = this;

    if(Array.isArray(user)) { // function(user-and-pw, callback)
        callback = password;
        password = user[1];
        user = user[0];
    }

    rscall('getaccountdetails', {
        login: user
        , password: password
        , withcookie: 1
    }, function(err, body) {
        if(err) { callback(err); return; }

        self.cookie = rskvresp(body).cookie;
        callback(null);
    });
}

RSSession.prototype.next_upload_server =  function(callback) {
    rscall('nextuploadserver', this.cookie, function(err, body) {
        if(err) { callback(err); return; }

        var id = body;
        var server = 'rs' + id + '.rapidshare.com';
        callback(null, server);
    });
}

RSSession.prototype.list_folders = function(callback) {
    rscall('listrealfolders', this.cookie, function(err, body){
        if(err) { callback(err); return; }

        var folders = rsaresp(body, ['id', 'parent', 'name']);

        var tree = { id: 0, name: '/', is_folder: true, children: {} };
        var lut = {};

        // make lookup table for folder ids
        var f;
        for(var i=0; i < folders.length && (f = folders[i]); i++) {
            // f.id, f.parent, f.name
            lut[f.id] = f;
            f.is_folder = true;
        }

        lut['0'] = tree;

        function tree_add(f) {
            if(!f.parent) return;
            if(lut[f.parent]) {
                //console.log('tree_add', [f.name,f.id], '->', [lut[f.parent].name,f.parent]);
                var p = lut[f.parent];
                p.children = p.children || {};
                p.children[f.name] = f;
            }

            return f;
        }

        var f;
        for(var i=0; i < folders.length && (f = folders[i]); i++) {
            tree_add(f);
        }

        callback(null, tree, folders);
    });
}

RSSession.prototype.resolve_folder_path = function(path, callback) {
    if(path[0] != '/') throw new Error('`path` must be absolute');
    if(path == '/') path = [];
    else path = path.split('/').slice(1);

    var orig_path = path.slice(1);

    this.list_folders(function(err, tree){
        if(err) { callback(err); return; }

        if(path.length == 0) { // root dir
            node = tree;
        } else {
            var node = tree, last_node;
            while(node && path.length > 0) {
                last_node = node;
                if(node && node.children && node.children[path[0]])
                    node = node.children[path.shift()];
                else
                    break;
            }
        }

        if(path.length > 0) {
            var path_found = orig_path.slice(0, orig_path.length - path.length);
            callback(new Error('ENOENT'), last_node, path_found, orig_path);
        } else {
            callback(null, node);
        }
    });
}

RSSession.prototype.resolve_path = function(path, callback) {
    var self = this;
    this.resolve_folder_path(path, function(err, node, found_path, full_path){
        if(!err) {
            callback(null, node);
        } else if(full_path.length - found_path.length == 1) {
            // only last path element failed to resolve -> might be a file

            var filter = { filename: full_path[full_path.length-1] };
            self.list_files(node, filter, function(err, files){
                if(files.length == 0) {
                    return callback.apply(self, arguments);
                } else {
                    return callback(null, files[0]);
                }
            });
        } else {
            return callback.apply(self, arguments);
        }
    });
}

RSSession.prototype.mkdir = function(path_, callback) {
    var self = this;

    if(path_[0] != '/') throw new Error('`path` must be absolute');
    var path = path_.split('/').slice(1);

    this.resolve_folder_path(path_, function(err, node, found_path, full_path){
        if(!err) { callback(null, node); }
        else if (err.message == 'ENOENT'){
            var i=found_path.length, parent=0;
            async.whilst(function(){ return i < full_path.length; },
                         function(callback){
                             var name = full_path[i];
                             self.add_folder(name, parent, function(err, f){
                                 if(err) { callback(err); return; }

                                 parent = f.id;
                                 i++;
                                 callback(null);
                             });
                         }, function(err){
                             if(err) { callback(err); return; }

                             // `parent' is really the id of the last folder
                             // that was created
                             callback(null, { id: parent });
                         });
        }
    });
}

RSSession.prototype.add_folder = function(name, parent, callback) {
    rscall('addrealfolder', {
        name: name
        , parent: parent
        , cookie: this.cookie
    }, function(err, body){
        if(err) { callback(err); return; }

        var folder = rsaresp(body, ['id']);
        if(folder.id != '-1') {
            callback(null, folder);
            } else {
                callback(new Error('ENOSPC'));
            }
    });
}

RSSession.prototype.list_files = function(folder, opt_filter, callback) {
    // realfolder=ID of the real folder to list files from. 0=root all=All folders (max. 3000 entries will be returned!)

    if(typeof opt_filter == 'function') {
        callback = opt_filter;
    } else if(opt_filter) {
        var filename = opt_filter.filename;

        if(opt_filter.fileids) {
            var fileids = opt_filter.fileids.join(',');
        }
    }

    rscall('listfiles', {
        realfolder: folder.id,
        fields: [ 'filename', 'size', 'uploadtime', 'md5hex' ].join(','),

        filename: filename,
        fileids: fileids,

        cookie: this.cookie
    }, function(err, body){
        if(err) { callback(err); return; }

        if(body == 'NONE') {
            return callback(null, []);
        }

        var files = rsaresp(body, [ 'id', 'name', 'size', 'mtime', 'md5' ]);

        callback(null, files);
    });

}

RSSession.prototype.delete_files = function(fileids, callback) {
    rscall('deletefiles', {
        files: fileids.join(','),
        cookie: this.cookie
    }, function(err, body) {
        if(err) { callback(err); return; }

        if(body == 'OK') {
            callback(null);
        } else {
            callback(new Error(body));
        }
    });
}

RSSession.prototype.delete_folders = function(folderids, callback) {
    rscall('delrealfolder', {
        realfolder: folderids.join(','),
        cookie: this.cookie
    }, function(err, body) {
        if(err) { callback(err); return; }

        if(body == 'OK') {
            callback(null);
        } else {
            callback(new Error(body));
        }
    });
}



RSSession.prototype.checkfiles = function(ids, names, callback) {
    var n;
    var tasks = [];
    while(n = try_fit(ids, names)) {
        tasks.push({
            ids: ids.splice(0, n),
            names: names.splice(0, n)
        });
    }

    async.map(tasks, function(task, callback) {
        do_checkfiles(task.ids, task.names, callback);
    }, function(err, results) {
        if(err) { callback(err); return; }

        var final = [];
        results.forEach(function(res) {
            final = final.concat(res);
        });

        callback(null, final);
    });

    /* ids and names needs to fit into the request constraints already */
    function do_checkfiles(ids, names, callback) {
        rscall('checkfiles', {
            files: ids.join(','),
            filenames: names.join(','),
            cookie: this.cookie
        }, function(err, body) {
            if(err) { callback(err); return; }

            var files = rsaresp(body, [
                'id', 'name', 'size', '_server', 'status', '_host', 'md5'
            ]);

            // rs $serverid $shorthost .rapidshare.com

            files = files.map(function(f){
                f.hostname = 'rs' + f._server + f._host + '.rapidshare.com';
                delete f._server;
                delete f._host;

                f.size = parseInt(f.size);

                f.exists = (f.status == '1');

                if(f.status == '0')
                    f.status = 0;

                return f;
            });

            callback(null, files);
        });
    }

    function try_fit(ids, names) {
        var max_id_len = 3000, max_name_len = 30000;

        var id_len = 0, name_len = 0;
        var id, name, i=0;
        function shift() {
            id = ids[i], name = names[i];
            i++;
            return id && name;
        }

        var n = 0;
        while(shift()) {
            id_len += id.length + 1, name_len += name.length + 1;
            if(id_len > max_id_len || name_len > max_name_len)
                break;

            n++;
        }

        return n;
    }
}


RSSession.prototype.createDownloadStream = function(file) {
    var url = rsurl('https://' + file.hostname + API, {
        sub: 'download',
        fileid: file.id,
        filename: file.name,
        cookie: this.cookie
    });

    return request.get(url);
}

RSSession.prototype.download_streaming = function(file, callback) {
    var self = this;
    this.checkfiles([ file.id ], [ file.name ], function(err, files){
        file = files[0];

        if(file.exists) {
            callback(null, self.createDownloadStream(file));
        } else {
            callback(new Error('ENOENT'));
        }
    });
}

RSSession.prototype.download_json = function(file, callback) {
    this.download_streaming(file, function(err, stream){
        if(err) { callback(err); return; }

        var chunks = [];

        stream.on('data', function(chunk) {
            chunks.push(chunk.toString());
        });

        stream.once('end', function() {
            var body = chunks.join('');
            if(body.match(/^ERROR:/)) {
                throw new Error(body);
            }

            try {
                callback(null, JSON.parse(body));
            } catch(e) {
                callback(e);
            }
        });
    });
}

function multipart_upload_stream(url, parts, callback) {
    var max_file_size = 2 * 1000 * 1000 * 1000; // 2GB

    // TODO: better GUID
    var boundary = Math.random().toString().slice(2);

    var len = 0;
    (parts = parts.map(make_part)).forEach(function(part){
        len += part.data.length;
        if(part.length)
            len += part.length;
    });

    var headers = {
        'Content-Type': 'multipart/form-data; boundary=' + boundary,
        'Content-Length': len
    };

    var opt = URL.parse(url);

    opt.method = 'POST';
    opt.headers = headers;
    var req = http.request(opt, function(res){});

    req.on('response', function(res) {
        callback(null, res);
    });

    // send all the parts
    async.forEachSeries(parts, function(part, callback) {
        // write multipart headers and part body if it was
        // in the part
        req.write(part.data);

        // if it's a streaming part do that.
        if(part.stream) {
            var on_data;

            part.stream.pipe(req, { end: false });
            part.stream.resume();

            part.stream.once('end', function(){
                callback(null);
            });

            part.stream.once('error', function(err){
                callback(err);
            });
        } else {
            callback(null);
        }
    }, function(err) {
        if(err) { callback(err); return; }

        req.end('\r\n--' + boundary + '--');
    });

    // TODO: filename encoding
    function make_part(p){
        var part = '--' + boundary + '\r\n'
            + 'Content-Disposition: form-data; name=' + '"' + p.name + '"'
            + (     p.filename ? ('; filename=' + '"' + p.filename + '"') : '')
            + '\r\n'
            + ( p.type ? ('Content-Type:' + p.type + '\r\n') : '' )
            + '\r\n'
            + ( p.body ? (p.body + '\r\n') : '');

        if(p.stream && !p.length) throw 'stream needs length';

        return {
            data: new Buffer(part)
            , stream: p.stream || null
            , length: p.length | null
        }
    }
}

RSSession.prototype.upload_file = function(file, callback){
    if(!file) throw new Error('`file` is required.');
    if(file.content && file.stream) throw 'file can\'t have content and stream';
    if(file.stream && !file.length) throw 'need stream length';

    var filecontent_part = {
        name: 'filecontent'
        , filename: file.name
        , body: file.content || null
        , stream: file.stream || null
        , length: file.length || null
    };

    var parts = [
        { name: 'sub', body: 'upload' },
        { name: 'cookie', body: this.cookie },
        { name: 'folder', body: file.folder || '0' },
        filecontent_part
    ];

    this.next_upload_server(function(err, server){
        if(err) { callback(err); return; }

        var url = 'http://' + server + API;
        multipart_upload_stream(url, parts, function(err, res){
            if(err) { callback(err); return; }

            var body = [];

            res.on('data', function(chunk){
                body.push(chunk.toString());
            });

            res.on('end', function(){
                body = body.join('');

                if(body.match(/^ERROR:/)) {
                    return callback(new Error(body));
                }

                var lines = body.split('\n');
                var complete = (lines.shift() == 'COMPLETE');

                file = rsaresp(lines.shift(), ['id', 'name', 'size', 'md5'])[0];

                callback(null, file);
            });
        });
    });
}

RSSession.prototype.upload_json = function(path, obj, callback) {
    var self = this;

    var json = JSON.stringify(obj);

    var filename = (path = path.split('/')).pop();

    this.resolve_folder_path(path.join('/'), function(err, folder){
        if(err) { callback(err); return; }

        self.upload_file({
            folder: folder.id
            , content: json
            , name: filename
        }, callback);
    });
}

/* Upload a stream that is larger than 2GB
 */
RSSession.prototype.upload_chunked = function(file, chunkSize, callback) {
    var self = this;
    var chunkId = 0;


    var tmppath = utils.tmp_path();
    var parts = [];
    var ended = false;

    var cstream = new ClampedStream(file.stream, chunkSize);
    cstream.pause();

    cstream.on('error', function(err){
        return callback(err);
    });

    do_chunk();

    function do_chunk(){
        if(cstream.readable == false)
            return callback(null, parts);

        var tmpstream = fs.createWriteStream(tmppath);

        cstream.pipe(tmpstream);
        cstream.resume();

        tmpstream.once('close', function(){
            fs.stat(tmppath, function(err, fstat) {
                if(err) { callback(err); return; }

                if(fstat.size == 0)
                    return do_chunk();

                var filedesc = {
                    name: file.name + '-' + (chunkId++),
                    folder: file.folder,
                    length: fstat.size,
                    stream: fs.createReadStream(tmppath)
                };

                filedesc.stream.pause();

                self.upload_file(filedesc, function(err, fres){
                    if(err) { callback(err); return; }

                    parts.push(fres);

                    process.nextTick(function() {
                        do_chunk();
                    });
                });
            });
        });
    }
}


