/*
 * node-rs: Rapidshare API Implementation
 * Copyright (C) 2012 dxld <dxld Ã„T darkboxed DOT org>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var fs = require('fs');
var util = require('util');
var Stream = require('stream');

module.exports = ClampedStream;

function ClampedStream(stream, maxSize){
    var self = this;
    this.stream = stream;
    this.readable = stream.readable;

    if(stream.bufferSize > maxSize)
        throw 'Stream buffer size must be less than `maxSize`';

    var on_data, on_end, on_close, on_error; // for cleanup

    this.rest = null;

    var size = 0;
    stream.on('data', function(chunk){
        var new_len = size + chunk.length;
        if(new_len > maxSize) {
            var fill = maxSize - size;

            var fillChunk = chunk.slice(0, fill);
            self.rest = chunk.slice(fill);

            chunk = fillChunk;
        }

        // special case where the boundaries check out
        if(self.rest && new_len == maxSize) {
            if(self.rest.length > 0)
                console.error('Um, rest_len > 0 even though it shouldn\'t be');
            self.rest = null;
        }

        size += chunk.length;

        self.emit('data', chunk);

        if(size == maxSize) {
            size = 0;

            stream.pause();

            self.emit('end');
        } else if(size > maxSize) {
            console.error('size > maxSize SHOULD NEVER HAPPEN');
        }
    });

    stream.on('end', function(){
        self.readable = false;
        self.emit('end');
    });

    stream.on('close', function(){
        self.readable = false;
        self.emit('close');

        self.emit('real_close');

        cleanup();
    });

    stream.on('error', function(err){
        self.readable = false;
        self.emit('error', err);

        cleanup();
    });

    function cleanup() {
        // stream.removeListener('data', on_data);
        // stream.removeListener('close', on_close);
        // stream.removeListener('end', on_end);
        // stream.removeListener('error', on_error);

        stream.removeAllListeners();

        self.removeAllListeners();
    }
}
util.inherits(ClampedStream, Stream);

ClampedStream.prototype.resume = function() {
    var self = this;
    if(this.rest) {
        var rest = this.rest;
        this.rest = null;

        process.nextTick(function(){
            self.emit('data', rest);
        });
    }

    this.stream.resume();
}

ClampedStream.prototype.pause = function() {
    this.stream.pause();
}
